#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vulnerability Scanner - Network Security Scanner Suite
Advanced vulnerability detection and assessment
Author: Alen Pepa
"""

import json
import re
import requests
from datetime import datetime
from typing import Dict, List, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

from utils.logger import get_logger
from utils.network_utils import is_valid_ip

class VulnerabilityScanner:
    """
    Advanced vulnerability scanner for network services
    """
    
    def __init__(self, timeout=10):
        self.timeout = timeout
        self.logger = get_logger()
        self.vulnerability_db = self.load_vulnerability_database()
        
    def load_vulnerability_database(self) -> Dict:
        """
        Load vulnerability database from file
        """
        try:
            with open('data/vulnerabilities.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.warning("Vulnerability database not found, using defaults")
            return self.get_default_vulnerabilities()
            
    def get_default_vulnerabilities(self) -> Dict:
        """
        Default vulnerability patterns if database file not found
        """
        return {
            "ssh": [
                {
                    "id": "SSH-001",
                    "name": "Weak SSH Configuration",
                    "severity": "medium",
                    "description": "SSH server may have weak configuration",
                    "banner_pattern": "SSH-1\\.",
                    "recommendation": "Upgrade to SSH version 2 and harden configuration",
                    "cve": "CVE-2008-5161"
                }
            ],
            "http": [
                {
                    "id": "HTTP-001",
                    "name": "Unencrypted HTTP",
                    "severity": "low",
                    "description": "Web server serves content over unencrypted HTTP",
                    "banner_pattern": "HTTP/1\\.",
                    "recommendation": "Implement HTTPS with proper SSL/TLS configuration",
                    "cve": None
                }
            ]
        }
        
    def scan_vulnerabilities(self, scan_results: List[Dict]) -> List[Dict]:
        """
        Scan for vulnerabilities based on port scan results
        """
        vulnerabilities = []
        
        for result in scan_results:
            if result.get('state') == 'open':
                host = result.get('host')
                port = result.get('port')
                service = result.get('service', '').lower()
                banner = result.get('banner', '')
                
                # Check for service-specific vulnerabilities
                service_vulns = self.check_service_vulnerabilities(service, banner, host, port)
                vulnerabilities.extend(service_vulns)
                
                # Check for port-specific vulnerabilities
                port_vulns = self.check_port_vulnerabilities(port, banner, host)
                vulnerabilities.extend(port_vulns)
                
        return vulnerabilities
        
    def check_service_vulnerabilities(self, service: str, banner: str, host: str, port: int) -> List[Dict]:
        """
        Check for vulnerabilities based on service type and banner
        """
        vulnerabilities = []
        
        # Get vulnerabilities for this service
        service_vulns = self.vulnerability_db.get(service, [])
        
        for vuln in service_vulns:
            # Check if banner matches vulnerability pattern
            banner_pattern = vuln.get('banner_pattern')
            if banner_pattern and re.search(banner_pattern, banner, re.IGNORECASE):
                vulnerability = {
                    'host': host,
                    'port': port,
                    'service': service,
                    'vulnerability_id': vuln['id'],
                    'name': vuln['name'],
                    'severity': vuln['severity'],
                    'description': vuln['description'],
                    'recommendation': vuln['recommendation'],
                    'cve': vuln.get('cve'),
                    'banner_matched': banner,
                    'timestamp': datetime.now().isoformat()
                }
                vulnerabilities.append(vulnerability)
                
        return vulnerabilities
        
    def check_port_vulnerabilities(self, port: int, banner: str, host: str) -> List[Dict]:
        """
        Check for vulnerabilities based on specific port numbers
        """
        vulnerabilities = []
        
        # Define critical ports that should not be exposed
        critical_ports = {
            23: {
                'name': 'Telnet Service Exposed',
                'severity': 'high',
                'description': 'Telnet service is exposed and transmits data in clear text',
                'recommendation': 'Disable Telnet and use SSH instead'
            },
            135: {
                'name': 'RPC Endpoint Mapper Exposed',
                'severity': 'medium',
                'description': 'Microsoft RPC Endpoint Mapper is exposed',
                'recommendation': 'Restrict access to RPC services or disable if not needed'
            },
            139: {
                'name': 'NetBIOS Session Service',
                'severity': 'medium',
                'description': 'NetBIOS session service is exposed',
                'recommendation': 'Disable NetBIOS or restrict network access'
            },
            445: {
                'name': 'SMB Service Exposed',
                'severity': 'high',
                'description': 'SMB service is exposed and may be vulnerable to attacks',
                'recommendation': 'Apply latest security patches and restrict SMB access'
            },
            1433: {
                'name': 'SQL Server Exposed',
                'severity': 'critical',
                'description': 'Microsoft SQL Server is directly accessible from network',
                'recommendation': 'Restrict database access and use VPN or firewall rules'
            },
            3306: {
                'name': 'MySQL Database Exposed',
                'severity': 'critical',
                'description': 'MySQL database server is directly accessible',
                'recommendation': 'Restrict database access and implement proper authentication'
            },
            3389: {
                'name': 'Remote Desktop Exposed',
                'severity': 'high',
                'description': 'Windows Remote Desktop is exposed to network',
                'recommendation': 'Use VPN access and enable Network Level Authentication'
            }
        }
        
        if port in critical_ports:
            vuln_info = critical_ports[port]
            vulnerability = {
                'host': host,
                'port': port,
                'service': 'unknown',
                'vulnerability_id': f'PORT-{port}',
                'name': vuln_info['name'],
                'severity': vuln_info['severity'],
                'description': vuln_info['description'],
                'recommendation': vuln_info['recommendation'],
                'cve': None,
                'banner_matched': banner,
                'timestamp': datetime.now().isoformat()
            }
            vulnerabilities.append(vulnerability)
            
        return vulnerabilities
        
    def check_web_vulnerabilities(self, host: str, port: int) -> List[Dict]:
        """
        Check for web-specific vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Check HTTP vs HTTPS
            if port == 80:
                vulnerability = {
                    'host': host,
                    'port': port,
                    'service': 'http',
                    'vulnerability_id': 'WEB-001',
                    'name': 'Unencrypted Web Traffic',
                    'severity': 'medium',
                    'description': 'Web server serves content over unencrypted HTTP',
                    'recommendation': 'Implement HTTPS and redirect all HTTP traffic to HTTPS',
                    'cve': None,
                    'timestamp': datetime.now().isoformat()
                }
                vulnerabilities.append(vulnerability)
                
            # Test for common web vulnerabilities
            web_vulns = self.test_web_headers(host, port)
            vulnerabilities.extend(web_vulns)
            
        except Exception as e:
            self.logger.error(f"Web vulnerability check failed for {host}:{port} - {e}")
            
        return vulnerabilities
        
    def test_web_headers(self, host: str, port: int) -> List[Dict]:
        """
        Test for missing security headers
        """
        vulnerabilities = []
        
        try:
            protocol = 'https' if port == 443 else 'http'
            url = f"{protocol}://{host}:{port}"
            
            response = requests.get(url, timeout=self.timeout, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': 'HSTS header missing',
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'Content-Security-Policy': 'CSP header missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerability = {
                        'host': host,
                        'port': port,
                        'service': 'http',
                        'vulnerability_id': f'HDR-{header.replace("-", "")}',
                        'name': f'Missing {header} Header',
                        'severity': 'low',
                        'description': description,
                        'recommendation': f'Add {header} security header to web server configuration',
                        'cve': None,
                        'timestamp': datetime.now().isoformat()
                    }
                    vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            self.logger.debug(f"Header check failed for {host}:{port} - {e}")
            
        return vulnerabilities
        
    def generate_vulnerability_report(self, vulnerabilities: List[Dict]) -> Dict:
        """
        Generate comprehensive vulnerability report
        """
        if not vulnerabilities:
            return {
                'total_vulnerabilities': 0,
                'severity_breakdown': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0},
                'affected_hosts': [],
                'recommendations': [],
                'summary': 'No vulnerabilities detected in the scan.'
            }
            
        # Count vulnerabilities by severity
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        affected_hosts = set()
        all_recommendations = set()
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'unknown')
            if severity in severity_counts:
                severity_counts[severity] += 1
            affected_hosts.add(vuln.get('host'))
            if vuln.get('recommendation'):
                all_recommendations.add(vuln.get('recommendation'))
                
        # Generate risk summary
        total_vulns = len(vulnerabilities)
        critical_high = severity_counts['critical'] + severity_counts['high']
        
        if critical_high > 0:
            risk_level = 'High Risk'
            summary = f"Found {total_vulns} vulnerabilities including {critical_high} critical/high severity issues requiring immediate attention."
        elif severity_counts['medium'] > 0:
            risk_level = 'Medium Risk'
            summary = f"Found {total_vulns} vulnerabilities with {severity_counts['medium']} medium severity issues that should be addressed."
        else:
            risk_level = 'Low Risk'
            summary = f"Found {total_vulns} low severity vulnerabilities that should be reviewed and addressed when possible."
            
        return {
            'total_vulnerabilities': total_vulns,
            'severity_breakdown': severity_counts,
            'affected_hosts': list(affected_hosts),
            'recommendations': list(all_recommendations),
            'risk_level': risk_level,
            'summary': summary,
            'vulnerabilities': vulnerabilities
        }
        
    def export_vulnerabilities(self, vulnerabilities: List[Dict], format_type: str = 'json') -> str:
        """
        Export vulnerabilities in specified format
        """
        if format_type == 'json':
            return json.dumps(vulnerabilities, indent=2)
        elif format_type == 'csv':
            import csv
            import io
            output = io.StringIO()
            if vulnerabilities:
                fieldnames = vulnerabilities[0].keys()
                writer = csv.DictWriter(output, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(vulnerabilities)
            return output.getvalue()
        else:
            return str(vulnerabilities)
            
    def get_vulnerability_statistics(self, vulnerabilities: List[Dict]) -> Dict:
        """
        Get statistical information about vulnerabilities
        """
        stats = {
            'total_count': len(vulnerabilities),
            'severity_distribution': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0},
            'most_common_vulnerabilities': {},
            'affected_services': set(),
            'hosts_with_vulnerabilities': set()
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'unknown')
            if severity in stats['severity_distribution']:
                stats['severity_distribution'][severity] += 1
                
            # Count vulnerability types
            vuln_name = vuln.get('name', 'Unknown')
            stats['most_common_vulnerabilities'][vuln_name] = stats['most_common_vulnerabilities'].get(vuln_name, 0) + 1
            
            # Track affected services and hosts
            if vuln.get('service'):
                stats['affected_services'].add(vuln.get('service'))
            if vuln.get('host'):
                stats['hosts_with_vulnerabilities'].add(vuln.get('host'))
                
        # Convert sets to lists for JSON serialization
        stats['affected_services'] = list(stats['affected_services'])
        stats['hosts_with_vulnerabilities'] = list(stats['hosts_with_vulnerabilities'])
        
        return stats

class CVEDatabase:
    """
    CVE (Common Vulnerabilities and Exposures) database interface
    """
    
    def __init__(self):
        self.logger = get_logger()
        
    def lookup_cve(self, cve_id: str) -> Optional[Dict]:
        """
        Look up CVE information (placeholder for real CVE database integration)
        """
        # This would integrate with actual CVE databases like NVD
        # For now, return basic structure
        if cve_id:
            return {
                'cve_id': cve_id,
                'description': f'Vulnerability {cve_id}',
                'severity': 'unknown',
                'published_date': None,
                'references': []
            }
        return None
        
    def get_latest_cves(self, service: str, limit: int = 10) -> List[Dict]:
        """
        Get latest CVEs for a specific service (placeholder)
        """
        # This would query actual CVE feeds
        return []